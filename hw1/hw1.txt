PROBLEM 1
Part (a)
Which of the following are acceptable behaviors in solving homeworks/projects?:
1. Looking up information relevant to the course online.
4. Asking the course staff for help.
8. Copying test cases from my classmates or Piazza when test cases are not graded.

Part (b):
Which of the following are recommended ways of writing code?
1. gedit
2. emacs
4. sublime
But you can essentially use anything as long as it compiles correctly with the VM compiler, as that's the environment which our code is graded on.

Part(c):
What is the late submission policy?
2. Each student has 3 late days of which only 1 can be used per HW.

Part(d):
After making a late submission by pushing your code to Gihub you should...
2. Complete the normal homework submission form.
4. Start the next assignment sooner.

PROBLEM 2
Part (a):
Which of the following git user interfaces are accepted and supported in this course?
1. Git Bash (Windows)
3. Terminal (Mac or Linux)

Part (b):
Provide the appropriate git command to perform the following operations:
1. Stage an untracked file to be committed. The file is called 'hw1q2b.cpp'.
git add <file>
2. Display the details of the last three commits in the repository.
git log -3

Part (c)
Let's say you staged three files to be committed. Then, you ran the following command: "git commit" What will git do?
Git will commit all three files

PROBLEM 4
After recursion, the end contents of 'in' will be {5,1,1,1,1}. The program will continue to call funcA with a decreasing value of 'n' until n=0 ( i.e. funcA(in, 5), funcA(in, 4), funcA(in, 3)... funcA(in, 0) ). Upon reaching zero, the program will return in[0] which will be equal to 1 since the orignal contents of in = {1,2,3,4,5} have not been modified yet. The program will then proceed back up the recrusive tree moving up to funcA(in, 1). Here, in[0] will be set equal to the returned value of 1 from funcA(in, 0). Next, the first instance of funcB will be called with n-1, this function will swap the values of in[0] and in[n-1] and return temp which is equal to 1. In the funcA(in, 2) call the previous return sets in[0] to 1. FuncB will then be called again swapping in[n-1] and in[0] and temp (equal to 1) will be returned. At this point in's contents will be {2,1,3,4,5}. However in[0] will then again be set equal to 1 in the line in[0] = funcA (in, n-1), making in = {1,1,3,4,5}. This pattern (swapping in[n-1] and in[0] then reseting in[0] to 1) will continue up the recursion tree until reaching funcA(in, 5). Because this is the last call, in[n-1] and in[0] will be swapped but there is no following call of funcA to set in[0] back to 1. Thus we are left with {5,1,1,1,1}.
